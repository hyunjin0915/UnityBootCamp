- ë©€í‹° í”„ë¡œì„¸ìŠ¤
- ë©€í‹° í”Œë ‰ì‹±
- ë©€í‹° ì“°ë ˆë“œ
- ë™ê¸°

---

ìœ ë‹ˆí‹° - ë„·ì½”ë“œ

ìœ ë‹ˆí‹° - ì›¹ì„œë²„ TCP - DB

ë ˆí”„íŠ¸ 4ë°ë“œ 

https://www.appsflyer.com/ko/

ìœ ë‹ˆí‹° ; ì»¬ë§ ì´ì „ ë‹¨ê³„ë¥¼ í•œ ê°€ì§€ ë°©ë²•ìœ¼ë¡œ ì •í•´ ë†“ê³  ì—”ì§„ì—ì„œ ë‹¤ í•´ì¤Œ

Direct 11; ê·¸ ì´ì „ ë‹¨ê³„ë¥¼ ë‹¤ ì„¤ì •í•´ì•¼ í•¨

### ìœ ë‹ˆí‹° íŒŒì´í”„ë¼ì¸

https://docs.unity3d.com/kr/2023.2/Manual/render-pipelines-overview.html

## ë Œë” íŒŒì´í”„ë¼ì¸?

Sceneì˜ ì»¨í…ì¸ ë¥¼ ê°€ì ¸ì™€ì„œ â†’ í™”ë©´ì— í‘œì‹œí•˜ëŠ” ì¼ë ¨ì˜ ì‘ì—… ìˆ˜í–‰

3D ëª¨ë¸ì˜ í‘œí˜„, ë¼ì´íŒ…, ê·¸ë¦¼ì, ì‰ì´ë”© ê°™ì€ **ì‹œê°ì  íš¨ê³¼ êµ¬í˜„**ì— ì‚¬ìš© 

íŒŒì´í”„ë¼ì¸ì€ ì„œë¡œ ë‹¤ë¥¸ ì…°ì´ë” ì¶œë ¥ì„ ì‚¬ìš©/ ì„œë¡œ ë‹¤ë¥¸ ê¸°ëŠ¥ ë³´ìœ 

ë Œë” íŒŒì´í”„ë¼ì¸ì— ë”°ë¼ ì‚¬ìš© ê°€ëŠ¥í•œ **í¬ìŠ¤íŠ¸ í”„ë¡œì„¸ì‹±** íš¨ê³¼ ì¢…ë¥˜ ì ìš©ë°©ë²• ë‹¤ë¦„**(ì„œë¡œ í˜¸í™˜X)**

íŒŒì´í”„ë¼ì¸ ê°„ì˜ ì „í™˜ì´ ì–´ë ¤ìš¸ ìˆ˜ ìˆìŒ 

### ë¹ŒíŠ¸ì¸ ë Œë” íŒŒì´í”„ë¼ì¸

ê¸°ë³¸ ë Œë” íŒŒì´í”„ë¼ì¸

ë²”ìš© ì‚¬ìš© - **ì»¤ìŠ¤í„°ë§ˆì´ì¦ˆ ì˜µì…˜ ì œí•œì (ì…ë§›ëŒ€ë¡œ ìˆ˜ì • ë¶ˆê°€)**

ê° ë¶„ì•¼ì— ë§ê²Œ ìµœì í™” ë¶ˆê°€ëŠ¥

### ìœ ë‹ˆë²„ì„¤ ë Œë” íŒŒì´í”„ë¼ì¸(URP) | ë²”ìš© ë Œë” íŒŒì´í”„ë¼ì¸

Scriptable render pipeline(SRP)ì˜ í…œí”Œë¦¿ ì—­í• 

ê´‘ë²”ìœ„í•œ í”Œë«í¼ì—ì„œ ìµœì í™”ëœ ê·¸ë˜í”½ìŠ¤ êµ¬í˜„ 

**ìì²´ post-processing ì†”ë£¨ì…˜**ì´ ë“¤ì–´ ìˆìŒ

### ê³ í•´ìƒë„ ë Œë” íŒŒì´í”„ë¼ì¸(HDRP)

Scriptable render pipeline

ê³ ì‚¬ì–‘ í”Œë«í¼, ìµœì‹  ê³ í•´ìƒë„ ê·¸ë˜í”½ìŠ¤ êµ¬í˜„ 

+) ìœ ë‹ˆí‹°ì˜ scriptable render pipeline api ì„ í†µí•´ ì»¤ìŠ¤í…€ ë Œë” íŒŒì´í”„ë¼ì¸ ìƒì„± ê°€ëŠ¥

### í…Œì…€ë ˆì´ì…˜

https://learn.microsoft.com/ko-kr/windows/win32/direct3d11/direct3d-11-advanced-stages-tessellation

---

## ë³µìŠµ

### ë¸”ë½í‚¹ API / ë™ê¸°

Socket

Bind

Listen

Accept

recv/send

close

Socket

Connect

recv/send

close

- í†µì‹ ì€ ë¬´ì¡°ê±´ byte[]
    
    **byte order**
    
- cpu - int, short, long ì½ëŠ” ìˆœì„œë„ ë‹¤ë¦„(ìœ ë‹ˆí‹°, c#)
    
    (int ì •ìˆ˜í˜• ë³´ë‚¼ ë•Œë§Œ ë¬¸ì œ ë°œìƒ )
    
- ë‹¤ëŒ€ì¼, ë‹¤ëŒ€ë‹¤ ê°€ëŠ¥í•˜ê²Œ? â†’ ë©€í‹°

# =================================

# ë©€í‹°ì“°ë ˆë“œ

ë¬¼ë¦¬ì ìœ¼ë¡œ ì‹¤ì œë¡œ ì—¬ëŸ¬ ê°œê°€ ëŒì•„ê°€ëŠ” ê±´ X

ë…¼ë¦¬ì ìœ¼ë¡œ êµ¬í˜„í•œ ê²ƒ

CPUì— í•¨ìˆ˜ ì‹¤í–‰ì„ ìš”ì²­í•˜ê³  ë‚˜ì˜¤ëŠ” ê²ƒ

### í´ë§ (Polling)

https://ko.wikipedia.org/wiki/%ED%8F%B4%EB%A7%81_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)

= í”„ë¡œê·¸ë¨ ìƒíƒœë¥¼ ì£¼ê¸°ì ìœ¼ë¡œ ê²€ì‚¬í•˜ì—¬ (ê³„ì† ì§ˆë¬¸ - ë“¤ì–´ì™”ëŠ”ì§€)

ì¼ì •í•œ ì¡°ê±´ì„ ë§Œì¡±í•  ë•Œ ì†¡ìˆ˜ì‹  ë“±ì˜ ìë£Œ ì²˜ë¦¬ë¥¼ í•˜ëŠ” ë°©ì‹

- ì¤„ì„ ì„¸ì›Œ ë†“ê³  - ì‚¬ìš©

### Socket.Select()

= ì—¬ëŸ¬ ê°œì˜ ì†Œì¼“ì„ ê°ì‹œí•˜ì—¬ ì½ê¸°, ì“°ê¸°, ì˜ˆì™¸ ì´ë²¤íŠ¸ê°€ ë°œìƒí•œ ì†Œì¼“ì„ í™•ì¸í•˜ëŠ” ì—­í• 

- **ë¹„ë™ê¸° ì²˜ë¦¬**
- **ë¸”ë¡œí‚¹ ë°©ì‹**
    
    ê°ì‹œí•˜ëŠ” ì†Œì¼“ì— ì´ë²¤íŠ¸ê°€ ë°œìƒí•  ë•Œê¹Œì§€ ëŒ€ê¸°í•  ìˆ˜ ìˆìŒ
    
    íƒ€ì„ì•„ì›ƒ ì„¤ì • ê°€ëŠ¥
    
- **ëŒ€ê·œëª¨ ì†Œì¼“ì„ ê°ì‹œí•  ë•ŒëŠ” ì„±ëŠ¥ì´ ë–¨ì–´ì§ˆ ìˆ˜ ìˆìŒ**

```csharp
public static void Select(
    IList checkRead, //ì½ì„ ìˆ˜ ìˆëŠ” ì†Œì¼“ ì €ì¥ ë¦¬ìŠ¤íŠ¸
    IList checkWrite, //ì“¸ ìˆ˜ ìˆëŠ” ì†Œì¼“ ì €ì¥ ë¦¬ìŠ¤íŠ¸
    IList checkError, //ì—ëŸ¬ê°€ ë°œìƒí•œ ì†Œì¼“ ì €ì¥ ë¦¬ìŠ¤íŠ¸ 
    int microSeconds //ëŒ€ê¸°í•  ì‹œê°„(-1ì€ ë¬´í•œëŒ€ê¸°)
);

```

í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ë©´ **ì´ë²¤íŠ¸ê°€ ë°œìƒí•œ ì†Œì¼“ë“¤ë§Œ** ë‚¨ìŒ!!

â†’ í˜¸ì¶œí•˜ê¸° ì „ì— ëª¨ë“  ê°ì‹œí•  ì†Œì¼“ì„ ë„£ê³ , í˜¸ì¶œ í›„ì—ëŠ” ì´ë²¤íŠ¸ê°€ ë°œìƒí•œ ì†Œì¼“ë§Œ ë‚¨ìŒ

### Multiplexing (ë©€í‹°í”Œë ‰ì‹±) [ë©€í‹°í”Œë ‰ì‹±](https://www.notion.so/b7af97daf71445d8be23833978b26dac?pvs=21)

= í•˜ë‚˜ì˜ ë¦¬ì†ŒìŠ¤(í”„ë¡œì„¸ìŠ¤, ìŠ¤ë ˆë“œ, ì†Œì¼“..)ë¥¼ ì´ìš©í•´ì„œ ì—¬ëŸ¬ ê°œì˜ ë°ì´í„° ìŠ¤íŠ¸ë¦¼(ë„¤íŠ¸ì›Œí¬ ì—°ê²°)ì„ ë™ì‹œì— ì²˜ë¦¬í•˜ëŠ” ê¸°ìˆ  

- **ì—¬ëŸ¬ ì…ë ¥ì„ í•˜ë‚˜ë¡œ ë¬¶ìŒ**
    
    ê°ì‹œí•˜ëŠ” ì†Œì¼“ì´ ì—¬ëŸ¬ ê°œ [listen][client1][cliend2] â€¦
    
    ì¤„ ì„¸ìš°ëŠ” ê²ƒ= ë©€í‹°í”Œë ‰ì‹±
    
- **ë¹„ë™ê¸° ë°©ì‹ìœ¼ë¡œ íš¨ìœ¨ì ì¸ ì²˜ë¦¬**
- **ì‹±ê¸€ ìŠ¤ë ˆë“œë¡œ ë‹¤ìˆ˜ì˜ ì—°ê²°ì„ ê´€ë¦¬í•  ìˆ˜ ìˆìŒ**
    
    ìŠ¤ë ˆë“œë¥¼ ì—¬ëŸ¬ ê°œ ìƒì„±í•˜ì§€ ì•Šê³ ë„ ë§ì€ ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ ë™ì‹œì— ì²˜ë¦¬ ê°€ëŠ¥ 
    

<aside>
ğŸ’¥

**Socket.Select() ë„ ë©€í‹°í”Œë ‰ì‹± ê¸°ìˆ  !** 
But. ì„±ëŠ¥ì´ ì¢‹ì€ ë°©ì‹ì€ X 

</aside>

| ë©€í‹°í”Œë ‰ì‹± ê¸°ìˆ  | ì„¤ëª… | íŠ¹ì§• |
| --- | --- | --- |
| **`select()`** | ì—¬ëŸ¬ ê°œì˜ ì†Œì¼“ì„ ê°ì‹œí•˜ì—¬ **ì¤€ë¹„ëœ ì†Œì¼“ë§Œ ì²˜ë¦¬** | ê°„ë‹¨í•˜ì§€ë§Œ **ë¹„íš¨ìœ¨ì ** (CPU ì ìœ ìœ¨ ë†’ìŒ) |
| **`poll()`** | `select()`ì™€ ìœ ì‚¬í•˜ì§€ë§Œ, ë” ë§ì€ ì†Œì¼“ì„ ê°ì‹œ ê°€ëŠ¥ | ì„±ëŠ¥ ê°œì„ ì´ ìˆì§€ë§Œ ì—¬ì „íˆ ë¹„íš¨ìœ¨ì  |
| **`epoll()`** | ë¦¬ëˆ…ìŠ¤ì—ì„œ ì œê³µí•˜ëŠ” ê³ ì„±ëŠ¥ ë©€í‹°í”Œë ‰ì‹± | **ìˆ˜ì‹­ë§Œ ê°œì˜ ì—°ê²° ì²˜ë¦¬ ê°€ëŠ¥** |
| **IOCP** | ìœˆë„ìš°ì—ì„œ ì œê³µí•˜ëŠ” ê³ ì„±ëŠ¥ ë¹„ë™ê¸° ë„¤íŠ¸ì›Œí¬ ëª¨ë¸ | **ìŠ¤ë ˆë“œ í’€ í™œìš©, ë†’ì€ ì„±ëŠ¥** |

**+) ë©€í‹°í”„ë¡œì„¸ìŠ¤ vs ë©€í‹°ìŠ¤ë ˆë“œ ?**

ë­ê°€ ë” ì¢‹ë‹¤ëŠ” ê±´ X

- ë¦¬ìŠ¤íŠ¸ ì‚¬ìš©í•  ë•Œ ì¤‘ê°„ì— ìš”ì†Œë¥¼ ë„£ì—ˆë‹¤ê°€ ëºë‹¤ê°€ í•˜ë©´ ì˜¤ë¥˜ë‚¨

~~Socket í•  ì¼ì´ ìˆìœ¼ë©´~~

~~accept, receive, send~~

~~Socket í•  ì¼ì´ ì—†ìœ¼ë©´~~

~~ì„œë²„ ì‘ì—…~~

~~NPC, AI~~

## Server

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Runtime.Remoting.Messaging;
using System.Text;
using System.Threading.Tasks;

namespace L250318
{
    internal class Program
    {

        static void Main(string[] args)
        {
            Socket listenSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            IPEndPoint listenEndPoint = new IPEndPoint(IPAddress.Parse("192.168.0.22"), 4000);

            listenSocket.Bind(listenEndPoint);
            listenSocket.Listen(10);
            
						//ì—°ê²°ëœ í´ë¼ì´ì–¸íŠ¸ ì†Œì¼“ ëª©ë¡ ì €ì¥ìš©
            List<Socket> clientSockets = new List<Socket>(); 
            //Select()ì—ì„œ ì‚¬ìš©, **ì½ê¸° ê°€ëŠ¥í•œ ì†Œì¼“ì„ ê°ì§€**í•˜ê¸° ìœ„í•´
            List<Socket> checkRead = new List<Socket>(); 

            while(true)
            {
                checkRead.Clear();
                checkRead = new List<Socket>(clientSockets);
                checkRead.Add(listenSocket); //ì„œë²„ ì†Œì¼“ë„ ì¶”ê°€í•˜ì—¬ ìƒˆë¡œìš´ ì—°ê²° ìš”ì²­ ê°ì§€

                //polling
                //checkRead ë¦¬ìŠ¤íŠ¸ì— ìˆëŠ” ì†Œì¼“ ì¤‘ì—ì„œ ë°ì´í„°ê°€ ìˆëŠ” ì†Œì¼“ ì°¾ê¸°
                Socket.Select(checkRead, null, null, -1);

                foreach (Socket findSocket in checkRead)
                {
		                //ìƒˆ í´ë¼ì´ì–¸íŠ¸ ì ‘ì† ì²˜ë¦¬ 
                    if (findSocket == listenSocket)
                    {
                        Socket clientSocket = listenSocket.Accept();
                        clientSockets.Add(clientSocket); //ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€í•˜ì—¬ ê³„ì† ê°ì‹œ 
                        Console.WriteLine("Connect Clinet : " + clientSocket.RemoteEndPoint);
                    }
                    //ê¸°ì¡´ í´ë¼ì´ì–¸íŠ¸ì˜ ë°ì´í„° ìˆ˜ì‹  ì²˜ë¦¬ 
                    else
                    {
                        byte[] headerBuffer = new byte[2]; //ë°”ì´íŠ¸ ìˆ˜ëŠ” ì„ íƒì‚¬í•­, ì›í•˜ëŠ” ìœ„ì¹˜ ì¡°ì •ì€ ArraySegment ì‚¬ìš© C#ì€ í¬ì¸í„°ê°€ ì—†ì–´ì„œ
                                                           //ì›ë˜ ì—¬ê¸°ì— ê¸¸ì´ìˆ˜ ë§ëŠ”ì§€ ì˜ˆì™¸ì²˜ë¦¬ ì¶”ê°€í•´ì¤˜ì•¼ í•¨
                        int recvLength = findSocket.Receive(headerBuffer, 2, SocketFlags.None);
                        if (recvLength > 0)
                        {
                            short packetLength = BitConverter.ToInt16(headerBuffer, 0);
                            packetLength = IPAddress.NetworkToHostOrder(packetLength);

                            //ì‹¤ì œ íŒ¨í‚· (header ê¸¸ì´ ë§Œí¼)
                            byte[] dataBuffer = new byte[4096];
                            //ì—¬ê¸°ë„ në¹„íŠ¸ë§Œí¼ ë°›ìœ¼ë¼ê³  ì˜ˆì™¸ì²˜ë¦¬ í•„ìš”
                            recvLength = findSocket.Receive(dataBuffer, packetLength, SocketFlags.None);

                            string jsonStr = Encoding.UTF8.GetString(dataBuffer);

                            Console.WriteLine(jsonStr);

                            JObject clientData = JObject.Parse(jsonStr);
                            

                            //Custom Packet  ë§Œë“¤ê¸°! -> í•¨ìˆ˜ë¡œ ë§Œë“¤ì–´ì£¼ë©´ ë¨
                            //ë‹¤ì‹œ ì „ì†¡ ë©”ì„¸ì§€
                            string message = "{ \"message\" : \"" + clientData.Value<String>("message") + "\"}";
                            byte[] messsageBuffer = Encoding.UTF8.GetBytes(message);
                            //ushort length = (ushort)messsageBuffer.Length; //ë©”ì„¸ì§€ ì „ì²´ ê¸¸ì´ ì €ì¥ 
                            ushort length = (ushort)IPAddress.HostToNetworkOrder((short)messsageBuffer.Length);

                            //ì „ì²´ ê¸¸ì´ ìë£ŒëŠ”
                            headerBuffer = BitConverter.GetBytes(length);

                            byte[] packetBuffer = new byte[headerBuffer.Length + messsageBuffer.Length]; //ì•ì— 2ë°”ì´íŠ¸ + ì§„ì§œ ë¬¸ìì—´ì˜ ê¸¸ì´

                            Buffer.BlockCopy(headerBuffer, 0, packetBuffer, 0, headerBuffer.Length);
                            Buffer.BlockCopy(messsageBuffer, 0, packetBuffer, headerBuffer.Length, messsageBuffer.Length);

                            foreach(Socket sendSocket in clientSockets)
                            {
                                int sendLength = sendSocket.Send(packetBuffer, packetBuffer.Length, SocketFlags.None);
                            }

                        }
                        else
                        {
                            //ë°›ìœ¼ë¼ í–ˆëŠ”ë° ë°›ì„ ê²Œ ì—†ì„ ë•Œ?
                            // = í´ë¼ì´ì–¸íŠ¸ê°€ ì—°ê²°ì„ ì¢…ë£Œí•œ ê²ƒìœ¼ë¡œ íŒë‹¨
                            findSocket.Close();
                            clientSockets.Remove(findSocket);
                        }

                    }
                }
            }
               
            listenSocket.Close();

        }
    }
}

```

## Client

```csharp
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Client
{
    internal class Program
    {
        struct Packet
        {
            //[][]
            string id; //20
            //[][]
            string message; //40
        }

        static void Main(string[] args)
        {
            Socket clientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            IPEndPoint clientEndPoint = new IPEndPoint(IPAddress.Parse("192.168.0.22"), 4000);
            clientSocket.Connect(clientEndPoint);

            while (true)
            {
                string InputChat;
                InputChat = Console.ReadLine();

                string jsonString = "{\"message\" : \"" + InputChat + ".\"}";
                byte[] messsage = Encoding.UTF8.GetBytes(jsonString);
                ushort length = ((ushort)messsage.Length); //ë©”ì„¸ì§€ ì „ì²´ ê¸¸ì´ ì €ì¥ 

                //ê¸¸ì´ ë„£ì„ ë‘ ê°œì§œë¦¬ ë²„í¼ 
                byte[] lengthBuffer = new byte[2];
                lengthBuffer = BitConverter.GetBytes(IPAddress.HostToNetworkOrder((short)length));

                byte[] buffer = new byte[2 + length]; //ì•ì— 2ë°”ì´íŠ¸ + ì§„ì§œ ë¬¸ìì—´ì˜ ê¸¸ì´

                Buffer.BlockCopy(lengthBuffer, 0, buffer, 0, 2);
                Buffer.BlockCopy(messsage, 0, buffer, 2, length);

                int sendLength = clientSocket.Send(buffer, buffer.Length, SocketFlags.None);
                //ë°›ì•„ì˜¬ ë•Œë„ ì•ì— ë‘ ê°œ ë°›ì•„ì™€ì•¼ í•¨ 
                //ì›ë˜ ë§Œì•½ 1ë°”ì´íŠ¸ë§Œ ë°›ìœ¼ë©´ ë¬´ì¡°ê±´ 2ê°œ ë°›ìœ¼ë¼ê³  whileë¬¸ ë°›ìœ¼ë¼ê³  ì²˜ë¦¬í•´ì¤˜ì•¼ í•¨

                int recvLength = clientSocket.Receive(lengthBuffer, 2, SocketFlags.None);
                length = BitConverter.ToUInt16(lengthBuffer, 0); // ê¸¸ì´ ì •ë³´ë¥¼ ë°›ì•„ì™€ì•¼ í•¨
                length = (ushort)IPAddress.NetworkToHostOrder((ushort)length);

                byte[] receiveBuffer = new byte[4096];
                recvLength = clientSocket.Receive(receiveBuffer, length, SocketFlags.None);

                string jsonStr = Encoding.UTF8.GetString(receiveBuffer);
                Console.WriteLine(jsonStr);

                //Thread.Sleep(100);
            }

            clientSocket.Close();

        }
    }
}

```

---

# Thread

C#ì€ ê°ì²´ì§€í–¥ â†’ Thread í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©

https://learn.microsoft.com/ko-kr/dotnet/api/system.threading.thread?view=net-8.0

- OS ì— Bí•¨ìˆ˜ë¥¼ ë“±ë¡í•´ì¤˜ -> instance
    
    `Thread thread1 = new Thread(new ThreadStart(B));`
    

- Bí•¨ìˆ˜ë¥¼ ë”°ë¡œ ì‹¤í–‰ ì‹œì¼œë‹¬ë¼ê³  ìš´ì˜ì²´ì œì— ë¶€íƒ
    
    `thread1.Start();`
    
    Bì—ì„œ ë§Œì•½ ë¬´í•œë£¨í”„ë¥¼ ëŒë©´ ì›ë˜ëŠ” ë‹¤ìŒ ëª…ë ¹ì–´ ì‹¤í–‰X 
    
    â†’ ThreadëŠ” ë”°ë¡œ ì‹¤í–‰í•˜ê¸° ë•Œë¬¸ì— ë‹¤ìŒ ëª…ë ¹ì–´ ì‹¤í–‰O
    

### Join()

https://learn.microsoft.com/ko-kr/dotnet/api/system.threading.thread.join?view=net-8.0

= ì´ ì¸ìŠ¤í„´ìŠ¤ê°€ ë‚˜íƒ€ë‚´ëŠ” ìŠ¤ë ˆë“œê°€ ì¢…ë£Œë  ë•Œê¹Œì§€ í˜¸ì¶œ ìŠ¤ë ˆë“œ ì°¨ë‹¨

(ì´ ìŠ¤ë ˆë“œê°€ ëë‚  ë•Œê¹Œì§€ ë©”ì¸ ìŠ¤ë ˆë“œê°€ ê¸°ë‹¤ë¦¼)

- ê¸´ ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” ìŠ¤ë ˆë“œê°€ ëë‚  ë•Œê¹Œì§€ ê¸°ë‹¤ë ¤ì•¼ í•  ë•Œ ì‚¬ìš©
- Join í•¨ìˆ˜ ì‚¬ìš©
    
    ```csharp
    //OS ì— Bí•¨ìˆ˜ë¥¼ ë“±ë¡í•´ì¤˜ -> instance
    Thread thread1 = new Thread(new ThreadStart(B));
    
    thread1.IsBackground = true;
    thread1.Start();
    
    thread1.Join(); //ë©”ì¸ threadì™€ í•©ì¹œë‹¤ : Bê°€ ëë‚  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¼
    
    Console.WriteLine("Hello world");
    
    ```
    
    â†’ ì´ë ‡ê²Œ í•˜ë©´ HelloWorld ì¶œë ¥X
    

### IsBackground

- **true**
    
    *ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œ*ë¡œ ë™ì‘ â†’ ë©”ì¸ ìŠ¤ë ˆë“œê°€ ì¢…ë£Œë˜ë©´ ìë™ ì¢…ë£Œ
    - ë¬´í•œ ë£¨í”„ ë„ëŠ” ë¡œê·¸ ì²˜ë¦¬, ê°ì‹œ ìŠ¤ë ˆë“œì—ì„œ ì‚¬ìš© 
    
- **false (default)**
*í¬ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œ*ë¡œ ë™ì‘ â†’ ëª…ì‹œì ìœ¼ë¡œ ì¢…ë£Œí•´ì•¼ í•¨
    
    ë©”ì¸ í•¨ìˆ˜ ì‹¤í–‰ì´ ì¢…ë‹¨ì ì— ë„ë‹¬í•˜ë”ë¼ë„ ì“°ë ˆë“œê°€ ì‘ì—…ì´ ëë‚  ë•Œê¹Œì§€ ì¢…ë£Œë˜ì§€ ì•Šìœ¼ë©° ê³„ì† ìœ ì§€(ë©”ì¸ë§Œ ì¢…ë£Œ)
    

+) ë§Œì•½ ë‘˜ ë‹¤ ì‚¬ìš©í•˜ë©´ Join() ì´ ìš°ì„ 

ì¦‰ IsBackground = true ì—¬ë„ Join()ì´ ê±¸ë ¤ ìˆìœ¼ë©´ ìŠ¤ë ˆë“œê°€ ëë‚  ë•Œê¹Œì§€ ëŒ€ê¸° 

```csharp
    internal class Program
    {
        static int Money = 0;

        static void Add()
        {
            for (int i = 0; i < 100000; i++)
            {
                Money++;
            }
        }
        static void Remove()
        {
            for (int i = 0; i < 100000; i++)
            {
                Money--;
            }

        }

        static void Main(string[] args)
        {
            //OS ì— Bí•¨ìˆ˜ë¥¼ ë“±ë¡í•´ì¤˜ -> instance
            Thread thread1 = new Thread(new ThreadStart(Add));
            Thread thread2 = new Thread(new ThreadStart(Remove));

            thread1.IsBackground = true;
            thread1.Start();
            thread2.IsBackground = true;
            thread2.Start();

            thread1.Join(); //ë©”ì¸ threadì™€ í•©ì¹œë‹¤ : Bê°€ ëë‚  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¼
            thread2.Join();

            Console.WriteLine(Money);
        }
    }
}
```

Moneyê°€ 0ì´ ì°íˆì§€ ì•ŠìŒ..!!

`Money++;` ëŠ” ì‚¬ì‹¤ ì›ìì„± ì‘ì—…ì´ ì•„ë‹ˆê³ ,

1.  `int temp = Money;`
2. `temp += 1;`
3. `Money = temp;`

1. ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ ê°’ì„ ë ˆì§€ìŠ¤í„°ë¡œ ë¡œë“œ
2. ê°’ì„ ì¦ê°€ ë˜ëŠ” ê°ì†Œ
3. ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ì— ê°’ì„ ì €ì¥

3ê°€ì§€ ê³¼ì •ì„ ê±°ì¹˜ê²Œ ë˜ëŠ”ë°, 

ì–´ì…ˆë¸”ë¦¬ì–´ë¡œ ë³€í™˜ë˜ë©´ ì„¸ ê³¼ì •ì„ í•œ ë²ˆì— ì²˜ë¦¬í•˜ì§€ ì•Šê³  ì¤‘ê°„ì— OS ì—ì„œ ëŠê²Œ ë¨ 

â†’ ê·¸ë˜ì„œ Moneyê°€ 0ì´ ì°íˆì§€ ì•ŠìŒ 

## â¡ï¸ Race Condition(ê²½ìŸ ìƒíƒœ)

ë™ê¸°í™”, ê°ì²´ ì²˜ë¦¬ 

â¡ï¸ [ì´ ì„¸ê°€ì§€ ê³¼ì •](https://www.notion.so/0324-1bf9103cc1eb809bbf22d0018b534f66?pvs=21)ì„ í•œ ë²ˆì— ì²˜ë¦¬í•˜ë¼ê³  ì„¤ì •í•´ì•¼ í•¨ 

**Atomic** í•˜ê²Œ !!

## lock

https://learn.microsoft.com/ko-kr/dotnet/csharp/language-reference/statements/lock

```csharp
    static Object _lock = new Object();

    volatile static int Money = 0;

    static void Add()
    {

        for (int i = 0; i < 100000; i++)
        {
            lock (_lock)
            {
                Money++;
            }

        }
    }
    static void Remove()
    {
        for (int i = 0; i < 100000; i++)
        {
            lock (_lock)
            {
                Money--;
            }

        }

    }
//...
```

### volatile

https://learn.microsoft.com/ko-kr/dotnet/csharp/language-reference/keywords/volatile

íŠ¹ì • ì¢…ë¥˜ì˜ ìµœì í™”ì—ì„œ ì œì™¸

- **ë°˜ë³µë¬¸ ë°”ê¹¥ì— lock? ì•ˆì— lock?**
    
    â†’ ìƒí™©ì— ë”°ë¼ì„œ ê°œë°œìì˜ íŒë‹¨ìœ¼ë¡œ 
    
    lockìœ¼ë¡œ ë“¤ì–´ê°”ë‹¤ê°€ ë‚˜ì™”ë‹¤ê°€ í•˜ëŠ” ê²ƒì„ ë°˜ë³µí•˜ëŠ” ê²Œ ì˜¤ë˜ ê±¸ë ¤ì„œ ëŠ¦ì–´ì§ˆ ìˆ˜ë„ ìˆê³ ,, 
    

### Interlocked

https://learn.microsoft.com/ko-kr/dotnet/api/system.threading.interlocked?view=net-9.0

= ì—¬ëŸ¬ ìŠ¤ë ˆë“œì—ì„œ ê³µìœ í•˜ëŠ” ë³€ìˆ˜ì— ëŒ€í•œ ì›ìì„± ì—°ì‚°ì„ ì œê³µ 

`Interlocked.Increment(ref Money); Interlocked.Decrement(ref Money);`

ì—°ì‚°ì´ ëë‚  ë•Œê¹Œì§€ ë¬¸ë§¥ êµí™˜í•˜ì§€ ë§ë¼ëŠ” ëœ»

ë¨¼ì € ê³µìœ  ì˜ì—­ì—ì„œ ì‚¬ìš©ë  ë©”ëª¨ë¦¬ë¥¼ ì°¾ê³ 

ë‹¨ë²ˆì— ëë‚  ìˆ˜ ìˆëŠ” ëª…ë ¹ì–´ë¼ë©´ **Interlocked ì‚¬ìš©**

ê·¸ê²Œ ì•„ë‹ˆë¼ë©´ **lock ìœ¼ë¡œ ì˜ì—­ì„ ì¡ì•„ì„œ ì‘ì„±**

### SpinLock

https://learn.microsoft.com/ko-kr/dotnet/api/system.threading.spinlock?view=net-9.0

## Mutex

[**â–ªï¸ ë®¤í…ìŠ¤(mutex)**](https://www.notion.so/mutex-00509a138c25497f92c1d6cb25f7ce04?pvs=21) 

í•´ë‹¹ ìì›ì„ ì¥ê³  ìˆëŠ” ìŠ¤ë ˆë“œë§Œì´ lockì„ ë°˜í™˜í•  ìˆ˜ ìˆìŒ â‡’ **ë¹„ì„ ì  ë°©ì‹** 

lockì„ ì†Œìœ í–ˆëŠ”ì§€ ìœ ë¬´ë¡œ ì„ê³„ì˜ì—­ì„ í—ˆìš©

â†’ ì„ê³„ì˜ì—­ì„ ì›í•˜ëŠ” ë‹¤ë¥¸ ì‘ì—… ìŠ¤ë ˆë“œë“¤ì€ ëŠì„ì—†ì´ lockì´ ì—´ë ¤ìˆëŠ”ì§€ ì²´í¬í•´ì•¼ í•¨

- ë¬¸ë§¥ êµí™˜ì„ ê±°ì¹˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ì„ê³„ ì˜ì—­ì„ ì§§ê²Œ ì‚¬ìš©í•˜ëŠ” ê²½ìš° íš¨ìœ¨ì„± ì¸¡ë©´ì—ì„œ ì¢‹ì„ ìˆ˜ ìˆìŒ
- **ìœ ì €ëª¨ë“œëŠ”** ê°™ì€ ìŠ¤ë ˆë“œë¼ë¦¬ë§Œ
    
    **ì»¤ë„ëª¨ë“œë¡œ** í•˜ë©´ ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ ì •ë³´ê¹Œì§€ ê°–ë‹¤ ì“¸ ìˆ˜ ìˆìŒ - Mutex)
    
    - ê²Œì„ ì‹¤í–‰ ì¤‘ì¸ë° ë‹¤ì‹œ ì‹¤í–‰í•˜ë©´ ì´ë¯¸ ì‹¤í–‰ ì¤‘ì´ë¼ê³  ëœ¨ê³  ì¤‘ë³µìœ¼ë¡œ ì‹¤í–‰ë˜ì§€ ì•ŠìŒ 
    â†’ OSì—ê²Œ ë¬¼ì–´ë³´ëŠ” ê²ƒ â†’ ë§¤ë²ˆ OSì—ê²Œ ë¬¼ì–´ë³´ê¸° ë•Œë¬¸ì— ì„±ëŠ¥ì´ ë–¨ì–´ì§ 
    â†’ ê¼­ í•„ìš”í•  ë•Œ ì•„ë‹ˆë©´ ì•ˆ ì“°ëŠ” ê²Œ

CPU ì½”ì–´ê°€ ë§Œì•½ 6ê°œë©´ Thread ë„ 6ê°œê°€ ì¢‹ê¸´ í•œë° ì •ë‹µì€ X

â†’ í”„ë¡œíŒŒì¼ë§í•´ì„œ ì„ íƒí•´ì•¼ í•¨

ë§Œì•½ 6ê°œê°€ fullë¡œ ê°€ë™? â†’  X, í•˜ë‚˜ëŠ” OSê°€ ì¨ì•¼ í•¨

## Deadlock (êµì°©ìƒíƒœ)

[3.8 ) êµì°© ìƒíƒœ(deadlock)](https://www.notion.so/3-8-deadlock-ea311e464d924390a3d6bbfe08543c31?pvs=21) 

lock ì´ í•˜ë‚˜ì¼ ë•ŒëŠ” ë°œìƒX

ë™ê¸°í™” ê°ì²´ë¼ê³  ë§ŒëŠ¥ì´ ì•„ë‹˜ 

- ë°œìƒí•˜ë©´ ì¢…ë£Œ ì‹œì¼œë²„ë¦¼
    
    `thread2.Abort();`
    

# âœ´ï¸ í”„ë¡œì íŠ¸ì— ì ìš©í•´ë³´ê¸° | Chating

---

1. í‚¤ ì…ë ¥ì„ ë°›ê¸°, `send í•¨ìˆ˜`
2. Network ì²˜ë¦¬, `recv í•¨ìˆ˜`

## â¡ï¸ **ë‘ í•¨ìˆ˜ ì²˜ë¦¬í•˜ëŠ” thread ë‘ ê°œ ë§Œë“¤ì–´ì„œ ì‹¤í–‰**ì‹œí‚¤ê¸°

### socket í•˜ë‚˜ ê³µìœ í•´ì„œ ì‚¬ìš©

TCP ëŠ” **full duplex(ì „ì´ì¤‘ í†µì‹ )**

â†’ í•˜ë‚˜ì˜ ì†Œì¼“ìœ¼ë¡œ ì£¼ê³  ë°›ê³  ë‘˜ ë‹¤ í•´ë„ ê´œì°®ìŒ (lock ê±¸ í•„ìš” ì—†ìŒ)

## Client.cs

```csharp
namespace Client
{
    internal class Program
    {
        static Socket clientSocket;
        static void ChatInput()
        {
            while (true)
            {
                string InputChat;
                InputChat = Console.ReadLine();

                string jsonString = "{\"message\" : \"" + InputChat + ".\"}";
                byte[] messsage = Encoding.UTF8.GetBytes(jsonString);
                ushort length = ((ushort)messsage.Length); //ë©”ì„¸ì§€ ì „ì²´ ê¸¸ì´ ì €ì¥ 

                //ê¸¸ì´ ë„£ì„ ë‘ ê°œì§œë¦¬ ë²„í¼ 
                byte[] lengthBuffer = new byte[2];
                lengthBuffer = BitConverter.GetBytes(IPAddress.HostToNetworkOrder((short)length));

                byte[] buffer = new byte[2 + length]; //ì•ì— 2ë°”ì´íŠ¸ + ì§„ì§œ ë¬¸ìì—´ì˜ ê¸¸ì´

                Buffer.BlockCopy(lengthBuffer, 0, buffer, 0, 2);
                Buffer.BlockCopy(messsage, 0, buffer, 2, length);

                int sendLength = clientSocket.Send(buffer, buffer.Length, SocketFlags.None);
            }
            
        }

        static void ReceiveThread()
        {
            while (true)
            {
                byte[] lengthBuffer = new byte[2];

                int recvLength = clientSocket.Receive(lengthBuffer, 2, SocketFlags.None);
                ushort length = BitConverter.ToUInt16(lengthBuffer, 0); // ê¸¸ì´ ì •ë³´ë¥¼ ë°›ì•„ì™€ì•¼ í•¨
                length = (ushort)IPAddress.NetworkToHostOrder((ushort)length);

                byte[] receiveBuffer = new byte[4096];
                recvLength = clientSocket.Receive(receiveBuffer, length, SocketFlags.None);

                string jsonStr = Encoding.UTF8.GetString(receiveBuffer);
                Console.WriteLine(jsonStr);

                //Thread.Sleep(100);
            }
        }
        static void Main(string[] args)
        {
            clientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            IPEndPoint clientEndPoint = new IPEndPoint(IPAddress.Parse("192.168.0.22"), 4000);

            clientSocket.Connect(clientEndPoint); //ì ‘ì†ì´ ì„±ê³µí•˜ë©´ 

            Thread chatInputThread = new Thread(new ThreadStart(ChatInput));
            Thread recvThread = new Thread(new ThreadStart(ReceiveThread));

            chatInputThread.IsBackground = true;
            recvThread.IsBackground = true;

            chatInputThread.Start();
            recvThread.Start();

            chatInputThread.Join();
            recvThread.Join();

            clientSocket.Close();

        }
    }
}

```

## Server

```csharp
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;

namespace Server
{
    class Message
    {
        public string message;
    }
    
    class Program
    {
        static Socket listenSocket;
        static List<Socket> clientSockets = new List<Socket>();

        static object _lock = new object();

				//í´ë¼ì´ì–¸íŠ¸ ì—°ê²°ì„ ìˆ˜ë½í•˜ëŠ” Thread
        static void AcceptThread()
        {
            while (true)
            {
                Socket clientSocket = listenSocket.Accept();

                lock (_lock)
                {
                    clientSockets.Add(clientSocket);
                }
                Console.WriteLine($"Connect client : {clientSocket.RemoteEndPoint}");
								
								//ì—°ê²°ëœ í´ë¼ì´ì–¸íŠ¸ ì†Œì¼“ì„ WorkThreadë¡œ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ ìƒˆë¡œìš´ Thread ìƒì„±
                Thread workThread = new Thread(new ParameterizedThreadStart(WorkThread)); 
                workThread.IsBackground = true; 
                workThread.Start(clientSocket);

            }

        }
        //í´ë¼ì´ì–¸íŠ¸ê°€ ë³´ë‚¸ ë°ì´í„° ì²˜ë¦¬ 
        static void WorkThread(Object clientObjectSocket)
        {
            Socket clientSocket = clientObjectSocket as Socket;
            while(true)
            {
                try
                {
                    byte[] headerBuffer = new byte[2];
                    int RecvLength = clientSocket.Receive(headerBuffer, 2, SocketFlags.None);
                    if (RecvLength > 0)
                    {
                        short packetlength = BitConverter.ToInt16(headerBuffer, 0);
                        packetlength = IPAddress.NetworkToHostOrder(packetlength);

                        byte[] dataBuffer = new byte[4096];
                        RecvLength = clientSocket.Receive(dataBuffer, packetlength, SocketFlags.None);
                        string JsonString = Encoding.UTF8.GetString(dataBuffer);
                        Console.WriteLine(JsonString);

                        JObject clientData = JObject.Parse(JsonString);

                        string message = "{ \"message\" : \"" + clientData.Value<String>("message") + "\"}";
                        byte[] messageBuffer = Encoding.UTF8.GetBytes(message);
                        ushort length = (ushort)IPAddress.HostToNetworkOrder((short)messageBuffer.Length);

                        headerBuffer = BitConverter.GetBytes(length);

                        byte[] packetBuffer = new byte[headerBuffer.Length + messageBuffer.Length];
                        Buffer.BlockCopy(headerBuffer, 0, packetBuffer, 0, headerBuffer.Length);
                        Buffer.BlockCopy(messageBuffer, 0, packetBuffer, headerBuffer.Length, messageBuffer.Length);
                        
                        //ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ë©”ì„¸ì§€ ì „ì†¡
                        lock(_lock)
                        {
                            foreach (Socket sendSocket in clientSockets)
                            {
                                int SendLength = sendSocket.Send(packetBuffer, packetBuffer.Length, SocketFlags.None);
                            }
                        }
                        
                    }
                    else
                    {
                        string message = "{ \"message\" : \" Disconnect : " + clientSocket.RemoteEndPoint + " \"}";
                        byte[] messageBuffer = Encoding.UTF8.GetBytes(message);
                        ushort length = (ushort)IPAddress.HostToNetworkOrder((short)messageBuffer.Length);

                        headerBuffer = BitConverter.GetBytes(length);

                        byte[] packetBuffer = new byte[headerBuffer.Length + messageBuffer.Length];
                        Buffer.BlockCopy(headerBuffer, 0, packetBuffer, 0, headerBuffer.Length);
                        Buffer.BlockCopy(messageBuffer, 0, packetBuffer, headerBuffer.Length, messageBuffer.Length);

                        clientSocket.Close();
                        lock (_lock)
                        {
                            clientSockets.Remove(clientSocket);

                            foreach (Socket sendSocket in clientSockets)
                            {
                                int SendLength = sendSocket.Send(packetBuffer, packetBuffer.Length, SocketFlags.None);
                            }
                        }

                        return;
                    }
                }
                catch (Exception e)
                {
                    Console.WriteLine($"Error ë‚¸ ë†ˆ : {e.Message} {clientSocket.RemoteEndPoint}");

                    string message = "{ \"message\" : \" Disconnect : " + clientSocket.RemoteEndPoint + " \"}";
                    byte[] messageBuffer = Encoding.UTF8.GetBytes(message);
                    ushort length = (ushort)IPAddress.HostToNetworkOrder((short)messageBuffer.Length);

                    byte[] headerBuffer = new byte[2];

                    headerBuffer = BitConverter.GetBytes(length);

                    byte[] packetBuffer = new byte[headerBuffer.Length + messageBuffer.Length];
                    Buffer.BlockCopy(headerBuffer, 0, packetBuffer, 0, headerBuffer.Length);
                    Buffer.BlockCopy(messageBuffer, 0, packetBuffer, headerBuffer.Length, messageBuffer.Length);

                    clientSocket.Close();
                    lock (_lock)
                    {
                        clientSockets.Remove(clientSocket);

                        foreach (Socket sendSocket in clientSockets)
                        {
                            int SendLength = sendSocket.Send(packetBuffer, packetBuffer.Length, SocketFlags.None);
                        }
                    }
                    return;
                }
            }
            
        }

        static void Main(string[] args)
        {
            listenSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

            IPEndPoint listenEndPoint = new IPEndPoint(IPAddress.Any, 4000);

            listenSocket.Bind(listenEndPoint);

            listenSocket.Listen(10);

            Thread acceptThread = new Thread(new ThreadStart(AcceptThread));
            acceptThread.IsBackground = true;
            acceptThread.Start();

            acceptThread.Join();
            
            listenSocket.Close();
        }
    }
}
```

## +) ë¹„ë™ê¸° Async

https://learn.microsoft.com/ko-kr/dotnet/api/system.net.sockets.tcpclient.connectasync?view=net-9.0

ë°”ë¡œ ì‹¤í–‰

ë‚˜ì¤‘ì— workThread ì— Selectì²˜ë¦¬(select ë§ê³  IOCP ì”€)

ì´ê±° í˜¸ì¶œí•  ë•Œë§ˆë‹¤ thread ìƒê¹€

????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

- ìŠ¤ë ˆë“œ ë§Œë“¤ê³  ì‚­ì œí•˜ëŠ” ê²ƒë„ ë©”ëª¨ë¦¬ ì‚¬ìš©
    
    ìŠ¤ë ˆë“œ ë¯¸ë¦¬ ë§Œë“¤ì–´ë†“ê³  suspend ë©ˆì¶°ë†“ê³  
    
    ê°’ ì´ˆê¸°í™”í•˜ê³  Resumeí•´ì„œ ì‚¬ìš©í•˜ê¸°ë„ í•¨ 
    

- ë‚´ê°€ ì“°ëŠ” Collectionì´ lockì„ ê±¸ì–´ì•¼ í•˜ëŠ”ì§€ ì•„ë‹Œì§€ í™•ì¸í•˜ëŠ” ë°©ë²•
    
    **â€œC# @@@ threadsafeâ€** ì´ë ‡ê²Œ ê²€ìƒ‰í•˜ë©´ ë¨
    
    ëª¨ë¥´ê² ìœ¼ë©´ ì¼ë‹¨ ë¬´ì¡°ê±´ lock ê±¸ì–´ë²„ë¦¬ì 
    
- ì›ë˜ Thread ê´€ë¦¬í•´ì£¼ëŠ” ë§¤ë‹ˆì €ë„ ë§Œë“¤ì–´ì¤˜ì•¼ í•¨
