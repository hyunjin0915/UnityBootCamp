- OOPë¥¼ ì´ìš©í•œ 2D ë Œë”ë§ ì—”ì§„ ë§Œë“¤ê¸° 2
- bit ì—°ì‚° í•´ë³´ê¸°
- íŒŒì¼ ì…ì¶œë ¥
- ë²„ë¸” ì •ë ¬

---

# ğŸŒ€ ë¹„íŠ¸ ì—°ì‚°

https://f-lab.kr/insight/bit-operation-efficiency-and-principles

## ì‚¬ìš©í•˜ëŠ” ì´ìœ 

- ì´ì§„ìˆ˜ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•˜ê¸° ë•Œë¬¸ì— ì‚°ìˆ  ì—°ì‚°ë³´ë‹¤ í›¨ì”¬ ë¹ ë¥¸ ì²˜ë¦¬ ì†ë„ ì œê³µ
- CPU ë‚´ë¶€ì—ì„œ ì§ì ‘ ìˆ˜í–‰ â†’ ì¶”ê°€ì ì¸ ë©”ëª¨ë¦¬ ì ‘ê·¼ ì—†ì´ ë¹ ë¥¸ ì—°ì‚° ê°€ëŠ¥
- íŠ¹ì • í”Œë˜ê·¸ë‚˜ ì„¤ì • ì €ì¥í•˜ëŠ” ë°ì— 1ë¹„íŠ¸ë§Œ ì‚¬ìš©í•˜ì—¬ ë©”ëª¨ë¦¬ ì ˆì•½ ê°€ëŠ¥
(ì—¬ëŸ¬ ìƒíƒœë¥¼ í•˜ë‚˜ì˜ ì •ìˆ˜ë¡œ ê´€ë¦¬í•  ë•Œ ìœ ìš©)

## C# ì˜ˆì‹œë“¤

```csharp
 byte a = 0; // ==> 0000 0000
 a = 1 << 7; // ==> 1000 0000
 Console.WriteLine(a);
```

- byteì—ëŠ” 255ê¹Œì§€ë§Œ ì €ì¥ ê°€ëŠ¥ â†’ ê·¸ ì´ìƒì€ **int í˜•**ìœ¼ë¡œ ë³€í™˜í•´ì•¼ ê°€ëŠ¥

```csharp
int a = 256; // ==> 00000000 00000000 00000001 00000000
//a = a >> 1; (128)
Console.WriteLine(Convert.ToString(a, 2));
```

- ë¹„íŠ¸ ì—°ì‚°ìœ¼ë¡œ **ë…¼ë¦¬ ì—°ì‚°**ë„ ê°€ëŠ¥
    
    ```csharp
    // << >> shift ì—°ì‚°ì
    
    //0001
    //0000 & ë…¼ë¦¬ê³± (and)
    //0000
    
    //0001
    //0001 | ë…¼ë¦¬í•©(or)
    //0001 
    
    //0001 ~ ë¶€ì •
    //1110
    
    //0101
    //0011 ^ XOR
    //0110
    ```
    
- 16ì§„ìˆ˜
    
    ```csharp
    //0000 0000 -> 16ì§„ìˆ˜
    //F    F    -> color
    //0xFF
    //255
    int R = 255;
    R = 0xFF;
    R = 0b11111111;
    Console.WriteLine(R); // 255
    // 15 ë¥¼ F, 4ê¸€ìë¥¼ 1ê¸€ìë¡œ í‘œí˜„í•  ìˆ˜ ìˆìŒ 
    ```
    

## ìœ ë‹ˆí‹° Layer ì—°ì‚°ì— ì‚¬ìš© | bit masking

https://docs.unity3d.com/kr/2023.2/Manual/layers-and-layermasks.html

```csharp
byte Player = 1; // 0b0000 0001
byte Camera = 2; // 0b0000 0010
byte UI = 4; // 0b0000 0100
byte Water = 8; // 0b0000 1000

byte layer = 0b00000000;
         //=>0b00000001
         //=>
layer = (byte)(layer | Player);
layer = (byte)(layer | UI);

if( (layer & (Player | Camera) ) > (byte)0)
{

}
```

- **1** : í¬í•¨í•  ë ˆì´ì–´/ **0** : ì œì™¸í•  ë ˆì´ì–´

â˜‘ï¸ **ì„±ëŠ¥** ë•Œë¬¸ì— ì‚¬ìš©

- ì‹¤ì œë¡œ ì‚¬ìš©í•  ë•ŒëŠ” `uint` í˜•(unsigned int) ìœ¼ë¡œ ì‚¬ìš©í•´ì•¼ í•¨
`uint Player = 1; //â€¦`
    - ìœ ë‹ˆí‹°ì—ì„œ ë ˆì´ì–´ **32ê°œ**ì„ - int !
- **ë¬¼ë¦¬ ê³„ì‚°**ì—ë„ ì‚¬ìš© Physics Setting - Layer Collision Matrix

### Classë¡œ ë§Œë“¤ì–´ì„œ ì‚¬ìš©í•˜ê¸° | BitArray

https://learn.microsoft.com/ko-kr/dotnet/api/system.collections.bitarray?view=net-8.0

```csharp
namespace L250224
{
    internal class Program
    {
        class BitArray32
        {
            public uint Data;

            public void Set(int position)
            {
                if (position > 0 && position <= 32) //ë²”ìœ„ ë¶€í˜¸ ì£¼ì˜!
                {
                    Data = Data | (uint)(1 << (position - 1)); //ì‚½ì…
                }
            }

            public void UnSet(int position)
            {
                if (position > 0 && position <= 32)
                {
                    Data = Data & ~(uint)(1 << (position - 1)); //ì‚­ì œ
                }
            }
        }
        static void Main(string[] args)
        {
            BitArray32 bitArray = new BitArray32();
            //00000000 0101
            bitArray.Set(3);
            bitArray.Set(1);
            Console.WriteLine(bitArray.Data);

            bitArray.UnSet(1);
            Console.WriteLine(bitArray.Data);
        }
    }
}

```

## 1ï¸âƒ£ ë¬¸ì œ í’€ì´

[bitmask.pdf](attachment:979a025a-03fb-475f-8feb-4237c2899eff:bitmask.pdf)

- ë‚´ í’€ì´
    
    ```csharp
    namespace L250224_2
    {
        internal class Program
        {
            static void Main(string[] args)
            {
                int n, num;
                n = int.Parse(Console.ReadLine());
    
                int[] arr1 = new int[n];
                int[] arr2 = new int[n];
                int[] map = new int[n];
    
                string[] mapArray = new string[n];
    
                for (int i = 0; i < n; i++) 
                {
                   num = int.Parse(Console.ReadLine());
                    arr1[i] = num;
                }
    
                for (int i = 0; i < n; i++)
                {
                    num = int.Parse(Console.ReadLine());
                    arr2[i] = num;
                }
    
                for(int i = 0;i < n; i++)
                {
                    map[i] = arr1[i] | arr2[i];
                    mapArray[i] = Convert.ToString(map[i], 2).PadLeft(n, '0');
                    //Console.WriteLine(mapArray[i]);
                }
                for (int i = 0; i < n; i++)
                {
                    for (int j = 0; j < n; j++)
                    {
                        if (mapArray[i][j] == '1')
                        {
                            Console.Write("#");
                        }
                        else
                        {
                            Console.Write(" ");
                        }
                    }
                    Console.WriteLine();
                }
            }
        }
    }
    
    ```
    

### í•´ì„¤

í•œ ë³€ì˜ ê¸¸ì´ 16ë¹„íŠ¸ ì´í•˜ â†’ 2ë°”ì´íŠ¸ê°€ ë‹´ê¸°ëŠ” ìë£Œí˜•ìœ¼ë¡œ í’€ì–´ì•¼ í•¨

![Image](https://github.com/user-attachments/assets/28278d8b-3eb0-42e2-bb58-2d8f4bd4b133)

**unsigned short ~** ë¡œ í•´ì•¼ í•¨(int ëŠ” 2^32 ì—¬ì„œ ê°€ëŠ¥)

- í¸ë¦¬í•œ C# ë²„ì „,,

```csharp
namespace L250224_2
{
    internal class Program
    {
        static void Main(string[] args)
        {
            int n = 5;
            int[] arr1 = { 9, 20, 28, 18, 11 };
            int[] arr2 = { 30, 1, 21, 17, 28 };

            int[] result = new int[n];

            for (int i = 0; i < n; i++)
            {
                result[i] = arr1[i] | arr2[i];
            }

            for (int i = 0;i < n; i++)
            {
                Console.WriteLine(Convert.ToString(result[i],2).Replace('1','#').Replace('0',' '));
            }
        }
    }
}

```

- ğŸ’€ ì–´ë µ,, ã…œã…œ

```csharp
namespace L250224_2
{
    internal class Program
    {
        static void Main(string[] args)
        {
            int n = 5;
            int[] arr1 = { 9, 20, 28, 18, 11 };
            int[] arr2 = { 30, 1, 21, 17, 28 };

            int[] result = new int[n];

            for (int i = 0; i < n; i++)
            {
                result[i] = arr1[i] | arr2[i];
            }

            int bitMask = 0b00000001;

            for (int i = 0; i < n; i++)
            {
                bitMask = 1 << (n - 1);
                for (int j = 0; j < 8; j++)
                {
                    Console.Write((bitMask & result[i]) > 0 ? "#" : " ");
                    bitMask = bitMask >> 1;
                }
                Console.WriteLine( );
            }
        }
    }
}

```

## 2ï¸âƒ£ ë¬¸ì œ í’€ì´
![image (6)](https://github.com/user-attachments/assets/8dc79512-e85c-4782-9614-2c85c9efe2c8)



- í’€ì´

```csharp
namespace L250224_2
{
    internal class Program
    {
        static void Main(string[] args)
        {
            uint N = 3;
            ulong[] X = new ulong[N];

            X[0] = 3;
            X[1] = 5;
            X[2] = 7;

            ulong result = 0;
            for (int i = 0; i < N; i++)
            {
                ulong value = 1;
                for (int n  = 0; n < 64; n++)
                {
                    //value *= 2;
										value = value << 1; 
                    if (X[i] <value)
                    {
                        //Console.WriteLine(value);
                        result ^= value;
                        break;
                    }
                }
                
            }
            Console.WriteLine(result);
        }
    }
}

```

- `value *= 2;` ë‘ `value = value << 1;`  ê°™ì€ ê²°ê³¼ ê°’ì´ì§€ë§Œ 
ì£¼ì–´ì§„ ìˆ«ìì˜ í¬ê¸°ê°€ ì»¤ì§ˆ ê²½ìš° ì„±ëŠ¥ ì°¨ì´ê°€ ë§ì´ë‚¨ â†’ **ë¹„íŠ¸ì—°ì‚°**ìœ¼ë¡œ í’€ì–´ì£¼ê¸°

<aside>
â—

ì½”ë”©í…ŒìŠ¤íŠ¸ í’€ì´í•  ë•Œ í•­ìƒ **ìë£Œí˜• í¬ê¸° + ë°˜ë³µë¬¸ ë³€ìˆ˜ ë²”ìœ„** ì£¼ì˜

</aside>

---

# +@

- ìë¦¿ìˆ˜ í‘œê¸°í•˜ëŠ” ë°©ë²•
    
    https://blockdmask.tistory.com/478
    
- í–‰ë ¬ ê³±ì€ ê³„ì‚°ì‹ì´ ë§ê¸° ë•Œë¬¸ì— CPU ë³„ë¡œ ë‹¤ë¥¸ ë°©ë²•ìœ¼ë¡œ ê³„ì‚°í•´ì¤˜ì•¼ í•¨
    - SIMD
- ì½”ë”©í…ŒìŠ¤íŠ¸ ë•Œ ì‹¤í–‰ ì†ë„ê°€ ë§ì´ ë–¨ì–´ì§€ë©´ í’€ì´ì—ì„œ powë‚˜ *ì„ ì‚¬ìš©í•˜ëŠ”ì§€ ë³´ê³ 
ë¹„íŠ¸ ì—°ì‚°ìë¡œ ìˆ˜ì •í•  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•˜ê¸°

# ğŸŒ€ ì—”ì§„ ë§Œë“¤ê¸° 2

í”Œë ˆì´ì–´ ê·¸ë¦¬ê³  â†’ ë§µ ê·¸ë¦¬ë©´ í”Œë ˆì´ì–´ê°€ ì§€ì›Œì§€ëŠ” ë¬¸ì œ

â¡ï¸ **ë Œë”ë§ ìˆœì„œ**ë¥¼ ì •í•´ì¤˜ì•¼ í•¨

## ë Œë”ë§ ìˆœì„œ ì„¤ì •

GameObject í´ë˜ìŠ¤ì— OrderLayer ë©¤ë²„ë³€ìˆ˜ ì¶”ê°€

ì²˜ë¦¬ ìˆœì„œ : Loading complete â†’ Sorting

### ğŸ«§ ë²„ë¸” ì •ë ¬ êµ¬í˜„í•´ë³´ê¸°



```csharp
int[] numbers = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
for (int i = 0; i < numbers.Length; i++)
{
    for (int j = 0; j < numbers.Length; j++)
    {
        if(numbers[i] < numbers[j])
        {
            int temp = numbers[i];
            numbers[i] = numbers[j];
            numbers[j] = temp;
        }
    }
}
```

- ì‹œê°„ë³µì¡ë„ O(n^2)

- ì„±ëŠ¥ì€ ë³„ë¡œì§€ë§Œ êµ¬í˜„ì´ ê°„ë‹¨

### World í´ë˜ìŠ¤ ë‚´ë¶€ì— Sort í•¨ìˆ˜ ì¶”ê°€

engine load ëë‚˜ê³  sort í•¨ìˆ˜ í˜¸ì¶œí•´ì„œ ì •ë ¬í•´ì£¼ê¸°

```csharp
public void Sort()
{
    for (int i = 0; i < gameObjects.Count; i++)
    {
        for (int j = i+1; j < gameObjects.Count; j++)
        {
            if (gameObjects[i].OrderLayer > gameObjects[j].OrderLayer)
            {
                GameObject temp = gameObjects[i];
                gameObjects[i] = gameObjects[j];
                gameObjects[j] = temp;
            }
        }
    }
}
```

+) `gameObjects.Sort()` - ì—°ì‚°ì ì˜¤ë²„ë¡œë”©ìœ¼ë¡œ êµ¬í˜„ë„ ê°€ëŠ¥í•¨ 

## ì¶©ëŒ ì—¬ë¶€ êµ¬í˜„

- isTrigger O : ì¶©ëŒí•  ë•Œ ë¬¼ë¦¬ëŸ‰ì€ ì „ë‹¬í•˜ì§€ ì•ŠìŒ
- ëª¨ì–‘ì´ë‘ ì¶©ëŒ ì²´í¬ ì •ë³´ëŠ” ë³„ê°œì„
- **static ì˜µì…˜** : ë°°ê²½ì— ì ìš© - ì²´í¬ ì•ˆí•˜ë©´ [***material draw call***](https://inhopp.github.io/unity/Unity2/)ì´ í™• ëŠ˜ì–´ë‚¨
    
    â†’ ê·¸ë¦¼ì ê·¸ë¦´ ë•Œ ì´ê±´ ë°°ê²½ì´ë¼ ì›€ì§ì´ì§€ ì•Šìœ¼ë‹ˆ ë¯¸ë¦¬ ê·¸ë¦¼ìë¥¼ ê·¸ë ¤ë†“ì„ ìˆ˜ ìˆìŒ 
    
    - light map - ë¯¸ë¦¬ ê·¸ë ¤ë†“ëŠ” ê²ƒ!! (ì‹¤ì‹œê°„ìœ¼ë¡œ ì•ˆ ê·¸ë¦¬ê³  ë¯¸ë¦¬,, - CPU ì•ˆ ì“°ê³  ë©”ëª¨ë¦¬ë§Œ ì‚¬ìš©)
        
        https://docs.unity3d.com/kr/2023.2/Manual/Lightmappers.html
        
        https://docs.unity3d.com/kr/current/Manual/optimizing-draw-calls.html
        
- ë¬¼ë¦¬ë‘ ê·¸ë¦¼ì´ë‘ ì˜ ë”°ë¼ë‹¤ë‹ˆê²Œ ìµœì í™”

### GameObject í´ë˜ìŠ¤ì— isTrigger, isCollide ë©¤ë²„ë³€ìˆ˜ ì¶”ê°€

### ë‚´ê°€ ì‘ì„±í–ˆë˜ ì½”ë“œ

```csharp
public override void Update()
{
    
    if(Input.GetKeyDown(ConsoleKey.W) )
    {
        temp = Y - 1;
        if(!OnCollisionEnter(Engine.Instance.scene[X][temp]))
        {
            Y--;
            
        }
    }
    else if (Input.GetKeyDown(ConsoleKey.A) )
    {
        temp = X - 1;
        if (!OnCollisionEnter(Engine.Instance.scene[temp][Y]))
        {
            X--;
            
        }
    }
    else if (Input.GetKeyDown(ConsoleKey.S) )
    {
        temp = Y + 1;
        if (!OnCollisionEnter(Engine.Instance.scene[X][temp]))
        {
            Y++;
            
        }
    }
    else if (Input.GetKeyDown(ConsoleKey.D) )
    {
        temp = X + 1;
        if (!OnCollisionEnter(Engine.Instance.scene[temp][Y]))
        {
            X++;
            
        }
    }
}
public override bool OnCollisionEnter(char colliison)
{
    if (colliison == ' ')
    {
        return false;
    }
    else if (colliison == '*')
    {
        return true;
    }
    
    else return false;
}
```

### í•´ì„¤ ì½”ë“œ

```csharp
//GameObject.cs
public bool PredictionCollection(int newX, int newY)
{
    for (int i = 0; i < Engine.Instance.world.GetAllGameObjects.Count; i++)
    {
        if (Engine.Instance.world.GetAllGameObjects[i].isCollide)
        {
            if ((Engine.Instance.world.GetAllGameObjects[i].X == newX) &&
                (Engine.Instance.world.GetAllGameObjects[i].Y == newY))
            {
                return true;
            }
        }
    }
    return false;
}
//Player.cs
public override void Update()
{
    
    if(Input.GetKeyDown(ConsoleKey.W) )
    {
        if(!PredictionCollection(X, Y-1))
        {
            Y--;
        }
    }
```

## Map ê·¸ë¦¬ê¸°

### ğŸŸ¡ íŒŒì¼ Byte ë‹¨ìœ„ë¡œ ë¶ˆëŸ¬ì˜¤ê¸°

- ë§µ ê·¸ë ¤ë†“ì€ í…ìŠ¤íŠ¸ íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¤ê¸° - **FileStream** ì‚¬ìš©
    
    https://learn.microsoft.com/ko-kr/dotnet/api/system.io.filestream?view=net-8.0
     `FileStream fs = new FileStream("level01.map", FileMode.Open);`
    
    ```csharp
    byte[] buffer = new byte[1024];
    FileStream fs = new FileStream("level01.map", FileMode.Open);
    int readCount = fs.Read(buffer, 0, 80);
    
    Console.WriteLine(readCount);
    Console.WriteLine(Encoding.UTF8.GetString(buffer));
    
    if (fs.CanRead)
    {
        readCount = fs.Read(buffer, 0, 80);
        Console.WriteLine(readCount);
        Console.WriteLine(Encoding.UTF8.GetString(buffer));
    }
    fs.Close(); //ê¼­ ë‹«ì•„ì¤˜ì•¼ í•¨
    ```
    
    - .map íŒŒì¼ ìœ„ì¹˜ : *C:\hj\GitHub\UnityBootCamp\L250218\bin\Debug\net8.0*
    
- whileë¬¸ìœ¼ë¡œ 80ë°”ì´íŠ¸ì”© ì½ê³  fs.CanReadê°€ false ë  ë•Œê¹Œì§€ ëŒë¦¬ë©´ â†’ file í¬ê¸° ë²”ìœ„ë¥¼ ë„˜ì–´ê°€ëŠ” ë¬¸ì œ â†’ **file size** êµ¬í•´ì„œ ì´ìš©
    
    ```csharp
    public void Load() //Engine.cs 
    {
        string tempScene = "";
        byte[] buffer = new byte[1024];
        FileStream fs = new FileStream("level01.map", FileMode.Open);
        int offset = 0;
    
        fs.Seek(0, SeekOrigin.End); //ì»¤ëŸ¬ë¥¼ ë§¨ëìœ¼ë¡œ ë³´ëƒ„
        long fileSize = fs.Position;
    
        fs.Seek(0, SeekOrigin.Begin); //ë‹¤ì‹œ ì»¤ì„œ ì²˜ìŒìœ¼ë¡œ
        int readCount = fs.Read(buffer, 0, (int)fileSize);
        tempScene = Encoding.UTF8.GetString(buffer);
        tempScene = tempScene.Replace("\0", "");
        scene = tempScene.Split("\r\n");
    ```
    

### ğŸŸ¡ StreamReader ì‚¬ìš©í•˜ê¸°

```csharp
 List<string> scene = new List<string>();

 StreamReader sr = new StreamReader("level01.map");
 while (!sr.EndOfStream) 
 {
     scene.Add(sr.ReadLine());
 }
 sr.Close();
```

## Try Catch

```csharp
try
{
    scene = new List<string>();

    StreamReader sr = new StreamReader(path);
    while (!sr.EndOfStream)
    {
        scene.Add(sr.ReadLine());
    }
    sr.Close();
}
catch (FileNotFoundException e)
{
    Console.WriteLine(e.FileName);
    Console.WriteLine(e.Source);
    Console.WriteLine(e.Message);
}
catch (Exception e)
{
    Console.WriteLine("ì—¬ê¸°ëŠ” íŒŒì¼ ì²˜ë¦¬ ì˜ˆì™¸ë§ê³  ë‹¤ë¥¸ ì˜ˆì™¸");
}
```

- Exception í´ë˜ìŠ¤ë¥¼ **ë§Œë“¤ì–´ì„œ ì‚¬ìš©**í•  ìˆ˜ë„ ìˆìŒ
    
    https://learn.microsoft.com/ko-kr/dotnet/standard/exceptions/how-to-create-user-defined-exceptions
    
- **finally** - network, íŒŒì¼ ì…ì¶œë ¥ ì²˜ë¦¬í•˜ëŠ” ë¶€ë¶„
    - íŒŒì¼ ë¶ˆëŸ¬ì˜¤ëŠ” ê³¼ì •ì´ ì˜ ì•ˆëì–´ë„ íŒŒì¼ì„ ë‹«ê¸°ëŠ” í•´ì•¼ í•˜ë‹ˆê¹Œ finally ì•ˆì—ì„œ
    `sr.Close()` ì²˜ë¦¬í•´ì£¼ê¸°
